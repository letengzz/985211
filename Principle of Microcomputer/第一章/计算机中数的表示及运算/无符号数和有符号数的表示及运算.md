# 无符号数的表示方法

**表示**：n位机中，n位均为数值位，**没有符号位**。

# 带符号数的表示方法

**表示**：n+1位机中，n位数值位，**1位符号位**。

### 机器数与真值

**机器数**：计算机中数的表示形式，以二进制的形式表示，位数通常为8的倍数 。一般数的最高位作符号位，“0”表示“`+`”， “1”表示“`-`”。
**真值**： 机器数所代表的实际数值。可用二进制
    表示，也可用其他进制表示。
**例**：一个8位机器数与它的真值对应关系如下：
    真值： X1= 84 = `+1010100B`       X2 = -84= `-1010100B` 
 机器数： [X1]<sub>机</sub>= `01010100B`        [X2]<sub>机</sub>= `11010100B`

**注意**：

1. 计算机内部存储单元数的正负是由人决定的。

   `1111 1111B` 作为有符号数可以当作-1的补码，无符号数可以二进制当作255。

### 原码表示法

**符号位**：0表示正，1表示负，位于最高位 (8位机D<sub>7</sub> 16位机D<sub>15</sub>)

**数值部分**：与真值的**二进制形式**一样

**例**：

> [+5]<sub>原</sub> = 0000 0101B = 05H
>
> [-5]<sub>原</sub> = 1000 0101B = 85H

### 反码表示法

**符号位**：0表示正，1表示负，位于最高位 (8位机D<sub>7</sub> 16位机D<sub>15</sub>)

**数值部分**：正数与真值的**二进制形式**一样，负数除符号位不变外，其他位取反(0-->1 1-->0)

**例**：

> [+5]<sub>反</sub> = 0000 0101B = 05H
>
> [-5]<sub>反</sub> = 1111 1010B = FAH

### 补码表示法

**符号位**：0表示正，1表示负，位于最高位 (8位机D<sub>7</sub> 16位机D<sub>15</sub>)

**数值部分**：正数与真值的**二进制形式**一样，负数等于反码+1

**例**：

> [+5]<sub>补</sub> = 0000 0101B = 05H
>
> [-5]<sub>补</sub> = 1111 1011B = FBH

### 移码表示法

**符号位**：0表示正，1表示负，位于最高位 (8位机D<sub>7</sub> 16位机D<sub>15</sub>)

**数值部分**：补码符号位取反，其他位不变

**例**：

> [+5]<sub>移</sub> = 1000 0101B = 85H
>
> [-5]<sub>移</sub> = 0111 1011B = 7BH

### 表示方法的比较

对于**有符号**的而言：

1. 二进制的最高位是符号位：0表示正数，1表示负数。
2. 正数的原码(`True Form`)、反码(`One's Complement`)、补码(`Two's Complement`)都一样(三码合一)。

   3. **负数的反码**=他的原码符号位不变，其他位取反(0-->1 1-->0)。
   4. **负数的补码**=它的反码+1

![image-20220404155037648](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/PM/First/%E6%9C%BA%E5%99%A8%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)

**表示方法的比较**：

1. **表示范围**：  

   ​    原码：-127~+127
   ​    反码：-127~+127
   ​    补码：-128~+127

2. **信息的冗余性**：原码、反码存在冗余编码，补码不存在冗余编码。

3. **运算的繁简程度**：原码、反码对加减法需要进行不同的计算，补码对加减法只需进行加法运算即可。


**注意**：

1. 原码、补码的表示范围：`八位`

   最大 `0 111 1111B` =`+127`

   最小 `1 111 1111B` =`-127`

2. n位原码、反码表示范围：

   > -(2^n-1^-1) ~ (2^n-1^-1)

3. n位补码表示范围：

   > -(2^n-1^) ~ (2^n-1^-1)

4. 人为把`-128`的补码规定为`80H`

5. 0的反码、补码都是0(补码仅有一个0)：

   ```c
   +0
       0000 0000原码
       0000 0000补码
       0000 0000反码
   -0    
       1000 0000原码
       1111 1111补码
       0000 0000反码 
   ```

6. 计算机运算的时候，都是以**补码的方式**来运算。	

   ```c
   //2的原码、反码、补码
   //0000 0010
   //-3的原码
   //1000 0011
   //-3的反码
   //1111 1100
   //-3的补码
   //1111 1101
   ```

### 求补码的方法

**常用方法**：

​	按位取反加 1

**简便方法**：

​	`模-(负数绝对值) = 补码`

**例**：

​	`37H`

​	八位(2<sup>8</sup>=256=`100H`)：`100H-37H = 0C9H`

## 计算机运算方法

​	计算机内部对于加减法运算采用相同的运算器（加法器）进行计算，即：将参与运算的各数值转换为补码进行加、减运算，最高位作为数值直接参与运算，变减法为加法运算。

### 补码加减法运算：

> [X+Y]<sub>补</sub>=[X]<sub>补</sub>+[Y]<sub>补</sub>

**例**：

<img src="https://cdn.jsdelivr.net/gh/letengzz/Two-C/img/PM/First/image-20211228162208174.png" alt="image-20211228162208174" style="zoom:67%;" />

> [X-Y]<sub>补</sub>=[X]<sub>补</sub>-[Y]<sub>补</sub>=[X]<sub>补</sub>+[-Y]<sub>补</sub>

**例**：

<img src="https://cdn.jsdelivr.net/gh/letengzz/Two-C/img/PM/First/image-20211228163024516.png" alt="image-20211228163024516" style="zoom:67%;" />

> [[X]<sub>补</sub>]<sub>补</sub>=[X]<sub>原</sub>

**例**：

[[-5]<sub>补</sub>]<sub>补</sub>= 1000 0101B = [-5]<sub>原</sub>

> ![image-20220404170052004](https://cdn.jsdelivr.net/gh/letengzz/Two-C@main/img/PM/First/%E8%A1%A5%E8%A1%A5.png)

**例**：

[-5]<sub>补</sub> --<sup>上述操作</sup>--> [5]<sub>补</sub>

### 无符号数加减运算

​	**加法运算，直接相加；减法相加，变补相加**

**例**：

<img src="https://cdn.jsdelivr.net/gh/letengzz/Two-C/img/PM/First/image-20211228163954072.png" alt="image-20211228163024516" style="zoom:67%;" />

### 总结

​	计算机只是按照补码的运算规则进行加减法运算，其无法判断出参与运算的数据究竟是有符号数还是无符号数。

# 机器数运算时注意事项

- 机器字长
- 补码加法或减法公式
- 补码与原码的转换公式
- 某数的正数与负数转换公式
- 补码与移码的转换
- 计算结果的机器数与真值的表示
