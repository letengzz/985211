# 程序设计基本概念

计算机不过是一种具有**内部存储能力**、由**程序自动控制**的电子设备。

**"程序"(program)：**连续执行的一条条能被计算机识别和执行的**有序指令**的集合。

**"程序设计语言"**：人与机器"对话"的一类媒介和工具，由语句(statement)组成。

**"语句"：**组成程序的**基本单位**。一个";"表示一个语句，单行一个";"叫空语句。每条语句都可以认为是一条指令

**机器语言：**(machine language)计算机直接使用的**二进制**形式的程序语言或机器代码。

**汇编语言：**(assembler language)一种面向机器的用**符号**表示的低级程序语言。相当于机器指令的助记符号，与机器语言相近。

**高级语言：**(high-level language)是易为人们所理解的**完全符号化**的程序设计语言。

**源程序**：用户用高级语言编写的程序。**C语言源程序文件名字后缀一般必须为"`.C`"**。

**目标程序：**由二进制代码组成的程序。**形式:0、1** C语言**后缀为"`.obj`"**。

**编译程序：**具有翻译功能的软件。由编译程序**转换**为**机器代码**。

**解释程序：**具有翻译功能的软件。由解释程序**转换**直接为**机器代码**。一条一条解释为二进制，必须从头到尾执行一遍。

**可执行程序**:二进制文件，可以运行的文件。

**连接器**：用于连接相关的目标文件以生成可执行文件。

**编译**: 有了C源文件，通过编译器将其编译成`.obj`文件(目标文件)。

**连接(linker)**：将目标模块和其他一些必要的功能模块装配在一起，生成可执行文件，**执行文件后缀为"`.exe`"**

**bit(位)**：计算机中最小的存储单位。`1byte = 8bit`

**byte(字节)**：计算机中基本存储单元。`1byte = 8bit`

**表达式**：由数字、算符、数字分组符号（括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。约束变量在表达式中已被指定数值，而自由变量则可以在表达式之外另行指定数值。

****

# 程序设计

**简单的程序设计一般包含以下几个部分**：

- (1)**确定数据结构**。根据任务书提出的要求、指定的输人数据和输出结果，确定存放数据的数据结构。

- (2)**确定算法**。针对存放数据的数据结构来确定解决问题、完成任务的步骤。

- (3)**编码**。根据确定的数据结构和算法,使用选定的计算机语言编写程序代码,输人到计算机并保存在磁盘上,简称编程。

- (4)**在计算机上调试程序**。消除由于疏忽而引起的语法错误或逻辑错误;用各种可能的输人数据对程序进行测试，使之对各种合理的数据都能得到正确的结果,对不合理的数据能进行适当的处理。

- (5)**整理并写出文档资料。**

# 算法

​	算法是指为解决某个特定问题而采取的确定且有限的步骤。一个算法应当具有以下特征：

- (1)**有穷性**。一个算法包含的操作步骤应该是有限的。也就是说,在执行若干个操作步票之后,算法将结束，而且每一步都在合理的时间内完成。

- (2)**确定性**。算法中每一条指令必须有确切的含义,不能有二义性,对于相同的输人必能得出相同的执行结果。

- (3)**可行性**。算法中指定的操作,都可以通过已经验证过可以实现的基本运算执行有限次后实现。

- (4)**有零个或多个输人**。在计算机上实现的算法是用来处理数据对象的,在大多数情况下这些数据对象需要通过输人来得到。

- (5)**有一个或多个输出**。算法的目的是为了求“解”,这些“解”只有通过输出才能得到。

  算法可以用各种描述方法来进行描述,最常用的是**伪代码**和**流程图**。

# 伪代码

​	伪代码是一种近似于高级语言但又不受语法约束的一种语言描述方式,这在英语国家中使用起来更为方便。

# 流程图

​	流程图是算法的一种**图像化**表示方式。能直观、清晰，更有利于人们设计与理解算法。

​	<img src="img/流程图/流程图基本图形.png" style="zoom: 50%;" >

​	由这些基本图形中的框和流程线组成的流程图来表示算法形象直观,简单方便。但是,这种流程图对于流程线的走向没有任何限制,可以任意转向,在描述复杂的算法时所占篇幅较多，费时费力且不易阅读。

​	随着结构化程序设计方法的出现,**1973年**美国学者`I.Nassi`和`B.Shneiderman`提出了一种新的流程图形式,这种流程图完全去掉了流程线,算法的每一步都用一个矩形框来描述,把一个个矩形框按执行的次序连接起来就是一个完整的算法描述。这种流程图用两位学者名字的第一个英文字母命名,称为**N-S流程图**。

# 结构化程序

​	结构化程序由三种基本结构组成。结构化的程序设计语言：层次清晰，便于按**模块化方式组织程序**，易于**调试和维护**。

- **顺序结构**

  如赋值语句、输入、输出语句都可构成顺序结构。当执行这些语句构成的程序时，将按照这些语句的先后顺序**逐条执行**，**没有分支**，**没有转移**。

  <img src="img/流程图/顺序结构流程图.png" style="zoom: 50%;" >

- **选择结构**

  如if语句、switch语句都可以构成选择结构。当执行到这些语句时，将根据不同的条件去执行不同分支中的语句

  <img src="img/流程图/选择结构流程图.png" style="zoom: 50%;" >

- **循环结构**

  如for循环、while循环、do-while循环。将根据各自的条件，使同一组语句重复执行多次或一次也不执行。

  - 当型循环的特点是：当指定的条件满足(成立)时，就执行循环体，否则就不执行。

  
  <img src="img/流程图/当型循环流程图.png" style="zoom: 50%;" >
  
  - 直到型循环的特点是：执行循环体直到指定的条件满足(成立)时就不再执行循环体。
  
  <img src="img/流程图/直到型循环流程图.png" style="zoom: 50%;" >

已经证明，由三种基本结构组成的算法可以解决任何复杂的问题。由三种基本结构所构成的算法称为**结构化算法**；由三种基本结构所构成的程序称作**结构化程序**。

例：先后输人若干个整数,要求打印出其中最大的数,当输人的数小于0时结束。用N-S流程图表示算法。

解题的思路是:先输人一个数,在没有其他数参加比较之前,它显然是当前最大的数，把它放到变量max中。让max始终存放当前已比较过的数中的最大值。然后输入第二个数,并与max比较,如果第二个数大于max，则用第二个数取代max中原来的值。如此先后输人和比较,每次比较后都将值大者放在max中,直到输入人的数小于0时结束。最后max中的值就是所有输入数中的最大值。

<img src="img/流程图/例题.png" style="zoom: 50%;" >

# 模块化结构

​	当计算机在处理较复杂的任务时,所编写的程序经常由上万条语句组成,需要由许多人来共同完成。这时常常把这个复杂的任务分解为若千个子任务,每个子任务，又分成很多个小子任务，每个小子任务只完成一项简单的功能。在程序设计时,用一个个小模块来实现这些功能,每个程序设计人员分别完成一个或多个小模块。我们称这样的**程序设计方法为“模块化”的方法,由一个个功能模块构成的程序结构为模块化结构。**

​	由于把一个大程序分解成若干相对独立的子程序,每个子程序的代码一般不超过一页纸,因此对程序设计人员来说,编写程序代码变得不再困难。这时只需对程序之间的数据传递做出统一规范,同一软件可由一组人员同时进行编写,分别进行调试，这就大大提高了程序编制的效率。

​	软件编制人员在进行程序设计的时候,首先应当集中考虑主程序中的算法,写出主程序后再动手逐步完成子程序的调用。对于这些子程序也可用调试主程序的同样方法逐步完成其下一层子程序的调用。这就是**自顶向下、逐步细化、模块化**的程序设计方法。

​	C语言是一种结构化程序设计语言。它提供了**三种基本结构**的语句;**提供了定义“函数”的功能**,在c语言中没有子程序的概念，它提供的**函数**可以完成子程序的所有功能;c语言允许对函故单独进行编译,从而可以实现模块化。另外，c语言还提供了丰富的数据类型。这些都为结构化程序设计提供了有力的工具。

# C语言简介

​	C语言是结构化程序设计语言的代表作

<img src="img/概述/C语言编译程序功能.png" style="zoom:50%;" >

  # C语言的诞生

  - 70年代，由美国贝尔实验室的`Thompson` (肯·汤普森) 和`D.M.Ritchie` (丹尼斯·里奇)合作开发的**UNIX**操作系统和C语言诞生了，C语言**最初用于开发系统级程序**，UNIX操作系统和C语言像一对孪生姐妹，她们以自己崭新的面貌一开始就引起了人们的广泛注意。后来又经过不断改进和实践的考验，这对姐妹已迅速成长和成熟，展示出了强大的生命力，被公认为最优秀的**操作系统**和**计算机语言**之一。近30年来，C语言帮助了UNIX的成功，UNIX的发展又推动了C语言的普及和发展。C语言应用非常广泛，我们熟知的Windows操作系统基本上是用C语言编写的。
  - 1972年哦1月 C语言诞生。
  - 1977年出现了不依赖于具体机器的C语言编译文本"可移植C语言编译程序"，使C语言移植到其他机器的工作大大简化。
  - 1978年11月贝尔实验室正式发布C语言。
  - 1983年，美国国家标准化协会(ANSI)根据C语言各种版本对C的发展和扩充，制定了新的标准ANSI C，比标准C 有了很大的发展。
  - 1987年，ANSI 公布了新标准--87 ANSI C。
  - 1988年，K&R 按照ANSI C修改了他们的《The C Programming Language》。
  - 1989年12月，ANSI完成标准的制定(ANSI C 或C89)
  - 1990年，国际标准化组织接受了87 ANSI C 为ISO C的标准(`ISO9899-1990`)。(ISO C或C90)
  - 1994年，ISO又修订了C语言标准。
  - 1999年，ISO发布了最近的C语言规范，被称为`C99`。
  - 2011年12月8日，国际标准化组织(ISO)和国际电工委员会(IEC)发布的`C11`标准是C语言的第三个官方标准，也是C语言的最新标准，该语言更好的支持了汉字函数名和汉字标识符，一定程度上实现了汉字编程。

  目前流行的C语言编译系统大多是以ANSI　C为基础进行开发的从而使C发展成一种独立于UNIX、独立于具体计算机类型的计算机语言。之后，C语言先后移植到大、中、小、微型计算机上，已独立于UNIX和PDP，风靡世界，成为当今世界上最为流行的、广大程序设计者最为喜爱的计算机语言之一。

  **说明**：不同版本 的C编译系统所实现的语言功能和语法规则略有差别，因此要了解所用的C语言智能编译系统的特点。

  # C语言的特点

  1. **代码级别的跨平台**。
  2. C语言是一种**结构化语言。**层次清晰，便于按**模块化方式组织程序**，易于**调试和维护**。
  3. C语言语句**简洁、紧凑、使用方便、灵活。**
  
       - 只有37个关键字，分为四个大类：
         
           - 数据结构关键字12个。
           - 控制语句关键字12个。
           - 存储类型关键字4个。
           - 其他关键字9字。
       
       - 9种控制语句
       
       - 数据构造能力强
       
       - 运算符丰富，共有34种运算符，可以实现其他高级语言难以实现的一些运算
       
       - 程序书写格式自由
  4. C语言程序**易于移植。**用C语言编写的程序可以从一种环境不加或稍加改动就能搬到另一种环境中运行。

  5. C语言由**强大的处理能力**。既可以用于系统软件的开发，也适合应用软件的开发。
  6. C语言是一种中级语言，**生成的目标代码质量高，运行效率高**。

  ​它既**具有高级语言的通用性及易写易读的特点，又具有汇编语言(低级语言)的"位处理"、"地址操作"等能力**。C语言允许直接访问物理地址，能进行位操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作。

  # C语言运行过程

​	**编辑**C源程序后经过 C编译程序**编译**之后生成一个后缀`.OBJ`的二进制文件(被称为**目标文件**，在计算机底层执行)，然后由称为**"连接程序"(Link)**的软件，把此`.OBJ`文件与C语言提供的各种库函数**连接**起来**生成**一个后缀为`.EXE`的**可执行文件**。(在计算机底层执行) 在操作系统环境下，只需**点击或输入**此文件的名字(而不必输入后缀`.EXE`)，该可执行文件就可以**运行**。

  <img src="img/概述/编译和执行过程.png" style="zoom: 50%;" >

  # C语言构成和格式

  **头文件**：含有函数的声明和预处理语句，用于帮助访问外部定义的函数。头文件的扩展名"`.h`"

  例：

  ```c
  #include <stdio.h>
  void main(){
      int a;
      printf("Hello World");
  }
  ```

  - 以#开始的语句称为预处理器指令
  
      #include语句不是必须的 但是 如果由该语句 就必须将它放到程序的开始处，行尾不可以加";"
  
      使用尖括号`< >`和双引号`" "`的区别在于头文件的搜索路径不同：
  
      - 使用尖括号`< >`，编译器会到系统路径下查找头文件；
      - 而使用双引号`" "`，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。
  
  - C都是由**主函数**开始执行 从**主函数**结束执行
  
  - main是主函数，C程序**有且只有一个**主函数。 
    main()函数是C程序的起点 main()函数可以返回一个值 也可以不返回值 如果某个函数没有返回值，那么在它的前面有一个关键字void
  
- 在函数的起始行后面用一对花括号"{ }" 括起来的部分为**函数体**。在函数定义的后面有一个左大括号 即"{"它表示函数的开始，后面是函数的主体 大括号也可以将语句块括起来,在函数定义的结尾处有一个右大括号 即"}"

- 函数体内通常有定义(说明)部分和执行语句部分。

  "int a" 为程序的**定义部分**。

  "print f("Hello World");"为程序的**执行部分**。

  执行部分的语句称为可执行语句，**必须放在定义部分之后**，语句的数量不限，程序中有这些语句向计算机系统发出操作指令。

- 函数主体中的每个语句都以**分号**结束。C程序中的一个语句可以跨越多行，并且用分号**通知编译器该语句已结束**。

# 注释

1. 必须成对出现。
2. "/" 和 "*" 之间不能有空格。
3. 注释可以出现在程序的任何地方。
4. 注释部分对程序运行不起作用。
5. 在注释之间不可以再嵌套/* */。

- **多行注释**


  ```c
  /*
  Hello World
  */
  ```

- **单行注释**


  ```c
  //
  ```

# 键盘输入语句

​	在编程中，需要接受用户输入的数据，可以使用键盘输入语句获取。

**步骤**：

1. **include <stdio.h>**。
2. 使用**scanf**函数。
3. 使用适当的**格式参数**接受输入。

```c
#include <stdio.h>
void main(){
    char name[] = "";
    int age = 0;
    double sal = 0.0;
    char gender = ' ';
    printf("请输入名字");
    scanf("%s",name);
    printf("请输入年龄");
    scanf("%d",&age);//需要存放到age变量指向的地址
    printf("请输入薪水");
    scanf("%lf",&sal);
    printf("请输入性别");
	scanf("%c",&gender);//接收到上面的回车符
    scanf("%c",&gender);//等待用户输入
    printf("\nname:%s age:%d sal:%.2f gender:%c",name,age,sal,gender);
}
```

# 规范代码风格

- ## 	正确的注释和注释风格

  如果注释的一个函数，可以使用**块注释**。

  如果注释函数中的某一个语句，使用**单行注释**。

- ## 	正确的缩进和空白

  使用一次tab操作，实现缩进，默认整体向右边移动。

  运算符两边习惯性各加一个空格。例：`2 + 4 * 5 `

# 	块的风格

- ## 行尾风格

```c
int max(int a,int b){
	if(a > b){
		return a;
	}else{
		return b;
	}
}
```

- ## 次行风格

```c
int max(int a,int b)
{    
	if(a > b)
	{        
		return a;    
	}
	else
	{        
		return b;    
	}
}
```

  # 标识符

​	在C语言中，有许多符号的命名，如变量名、函数名、数组名等，都必须遵守一定的规则，按此规则命名的符号称为**标识符**。

**命名规则**：

1. 只能由字母、数字和_(下划线)组成。
2. 必须以字母或_(下划线)开头。
3. 不能包含空白字符(**换行符、空格和制表符称为空白字符**)。
4. C语言中的关键字、保留字不能用作标识符名。
5. 区分大小写

**注意：**

- 大写字母和小写字母是不同的两个字符，程序中不得出现仅靠大小写区分的相似的标识符。

- 标识符长度：C语言编译系统是有规定的，即标识符的前若干个字符有效，超过的字符不被识别。

- 所有宏定义、枚举类型、常量(只读变量)全用大写字母命名，用下划线分割单词。如：

  ```c
  #define FILE_PATH "/usr/tmp"
  ```

- 定义变量要初始化。定义变量时编译器并不一定清空了这块内存，它的值可能是无效数据，运行程序，会异常退出。

- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz (驼峰法，小驼峰)[大驼峰 XxxYyyZzz]

  ```c
  int tankShotGame  = 1;
  ```

**标识符可以分为三类：**

1. ## 关键字

   ​	C语言已经预先规定了一批标识符，它们在程序中都代表着固定的含义，不能另作他用，这些标识符称为关键字

   ​	**C语言关键字 -->  [Here](#C语言关键字)**


2. ## 预定义标识符

   ​	C语言中**预先定义并具有特定含义**的标识符称为预定义标识符，如C语言提供的库函数的名字(如 `printf`)和预编译处理命令(如`define`)等。C语言允许把这类标识符重新定义另作他用,但这将使这些标识符失去预先定义的原意。鉴于目前各种计算机系统的C语言都一致把这类标识符作为固定的库函数名或预编译处理中的专门命令使用,因此为了避免误解,建议用户不要把这些预定义标识符另作他用。


3. ## 用户标识符

   ​	由用户根据**需要**定义的标识符称为用户标识符，又称自定义标识符。用户标识符一般用来给变量、函数、数组等命名。程序中使用的用户标识符除要遵守标识符命名规则外,还应注意做到"**见名知义**”,即选择具有一定含义的英文单词或汉语拼音作为标识符,如number1 , red 、yellow , green , work等,以增加程序的可读性。
   ​	如果用户标识符与关键字相同,则在对程序进行编译时系统将给出出错信息;如果用户标识符与预定义标识符相同,系统并不报错,只是该预定义标识符将失去原定含义,代之以用户确认的含义,这样有可能会引发一些运行时错误。

# 常量

​	在程序运行过程中，**其值不能被改变的量**叫变量，又叫做**字面值**。C语言中，有整型常量、实型常量、字符常量、字符串常量等类型。

常量的命名规则：**都用大写，中间用_**

**常量的特点**：

- 在程序中保持不变，定义后不能进行修改。
- 在程序内部频繁使用。
- 需要用比较简单的方式替代某些值。


​	整型常量和实型常量又称为**数值型数据**，它们有正值和负值的区分。

## 	整型常量

​	只用数字表示，不带小数点，例如12、-1等。

1. **十进制**表示：用一串连续的数字表示十进制数。例:345 31684 0  -23456
       **只有十进制可以是负数。**
2. **八进制**表示：以数字0开头的一个连续数字序列，序列中只能有0-7这八个数字。
   例:045、`06745l`是合法的八进制数而019、423、-078是非法的八进制数。
3. **十六进制**表示：以`0X`或`0x`开头的连续数字和字母序列，序列中只能有0-9、A-F和 a-f这些数字和字母,字母a、b、c、d、e、f分别对应数字10、11、12、13、14、15，大小写均可。
4. **无符号整数**表示：以后缀为 `U`为无符号整数(unsigned)，后缀可以是大写也可以小写。
5. **长整数**表示：以后缀为 `L`为长整数(long)，后缀可以是大写也可以小写。

**注**：八进制和十六进制只能是整数。

```c
#include <stdio.h>
main(){
    printf("十六进制0x80的十进制值为:%d\n",0x80);
    printf("八进制0200的十进制值为:%d\n",0200);
    printf("十进制128的十进制值为:%d\n",128);
    printf("十进制128的十六进制值为:%x\n",128);
    printf("十进制128的八进制值为:%o\n",128);
}
```

## 	实型常量

​	必须用带小数点的数表示，例如3.14159、0.0等。

​	**指数形式**：以幂的形式表示，以字母e或者E后跟一个以10为底的幂数。

例：`2.3e5`、`500e-2`、`.5E3`、`4.5e0`  而   `e4`、`.5e3.6`、`.e5`、`e`都不合法

​		2.3*10<sup>5</sup>

## 	字符型常量

​	用英文单引号括起来，只保存一个字符'a'、'b' 、'*' ，还有转义字符 '\n' 、'\t'。

​	**说明**：区分大小写、空格符也是字符常量、只能包含一个字符、必须用单引号，双引号也是字符串常量，可以和整型互换。

`'A'`和`'l'`还有转义字符`'\t'`等

## 	字符串常量

​	用英文的双引号引起来 可以保存多个字符："`NICE`"

## 	符号常量

​	在C语言程序中,可以用一个符号名来代表一个常量，称为**符号常量**。这个符号名必须在程序中进行特别的“指定”,并符合标识符的命名规则。如：`PI`

## #define预处理器定义常量

```c
#include <stdio.h>
//宏定义
#define MY_AGE 1000

void main() {
    printf("%d",MY_AGE);
}
```

## const关键字定义常量

```c
#include <stdio.h>

const int MY_AGE = 1000;

void main() {
    printf("%d",MY_AGE);
}
```

**区别**：  

1. const定义的常数带类型，define不带类型。

2. const是在编译、运行的时候起作用，而define是在编译的预处理阶段起作用。

3. define只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应。

   ```c
   #include <stdio.h>
   
   #define A 1
   #define B A+3
   //#define B (A+3)
   #define C A/B*3
   void main(){
       //C = A/A+3*3 = 1/1+3*3=1+9=10
       printf("%d",C);
       //C = A/(A+3)*3 = 0
   }
   ```

4. const常量可以进行调试的，define是不能进行调试的，主要是预编译阶段就已经替
     换掉了，调试的时候就没它了。

5. const不能重定义，不可以定义两个一样的，而define通过undef取消某个符号的定义
     再重新定义。

     ```c
     #include <stdio.h>
     
     const double PI = 1.2;
     //const double PI = 3.14;
     #define PI 3.14
     #undef PI
     #define PI 3.15
     void main(){
         //C = A/A+3*3 = 1/1+3*3=1+9=10
         printf("%f",PI);
     }
     ```

6. define可以配合#ifdef、#ifndef、_#endif来使用，可以让代码更加灵活，比如我们
    可以通过#define 来启动或者关闭调试信息。
    
    ```c
    #include <stdio.h>
    
    #define DEBUG
    void main(){
    #ifdef DEBUG
        printf("调试信息");
    #endif
    #ifndef DEBUG
        printf("调试信息失败");
    #endif
    }
    ```

# 变量

​	在程序的运行过程中，值可以改变的量称为变量。**变量是程序的基本组成单位**。

**变量使用基本步骤**：

   1. 声明变量

      ```c
      int num;
      ```

   2. 赋值

      ```c
      num = 62;
      ```

   3. 使用

      ```c
      printf("%d",num);
      ```

**说明：**

 1. 每个变量有一个名字作为标识，它是属于用户标识符。

 2. 变量必须先定义后使用**(定义后还得赋值才能用)**。

    ```c
    //定义变量后，给变量赋值
    int a;int b,c;
    a=1;  b=2;c=3;
    //定义时初始化变量
    int a=1;int b=2,c=3;
    ```

**注意事项**:

​	变量表示内存中的一个存储区域(不同的数据类型，占用的空间大小不一样)。

​	该区域有自己的名称和类型。

​	变量必须先声明，后使用。

​	该区域的数据可以在**同一类型范围**内不断变化。

​	变量在同一作用域内不能重名。

​	变量的三要素(数据类型、变量名、值)缺一不可。

# 数据类型

​	每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节来表示)

​	<img src="img/数据类型/概述.png" style="zoom:67%;" >

## 整型数据

​	分为基本型、短整型、长整型、无符号四种。**整数可以精确存放**

<img src="img/数据类型/整型变量.png" style="zoom:50%;"  >

​	在不同系统上，数据类型的长度不一样 int 2字节或4字节。

​	**占位符**： -->  [Here](#C语言占位符)

​	**写二进制数据**：以0b开头为2进制，`0b11101101`

​	**八进制数据**：以0开头为8进制，`045`，`021`

​	**十六进制数据**以0x开头为16进制，`0x21458adf`

​	**进制**： --> [Here](#进制)

​	**int补充知识**： -->  [Here](#int补充知识)

## 实型数据

<img src="img/数据类型/实型变量.png" style="zoom:50%;"  >

​	在内存中，实数一律以**指数形式**存放。**浮点数是近似值，存在误差**

​	**浮点数** = **符号位** + **指数位** + **尾数位**

​	**单精度**：数字后面加 "f"或"F" `2.3f`   不加"f" 是从double到float截断。

​	**双精度**：2.3，默认为双精度。

​	**占位符**： -->  [Here](#C语言占位符)

## 字符型数据

<img src="img/数据类型/字符型变量.png" style="zoom:50%;"  >

​	字符类型可以表示**单个字符**，允许使用单个字符、转义字符、ASCII、Unicode。

​	字符类型 存储到计算机中，需要将字符对应的**码值**(整数)找出来。

​	**存储**：字符'a' ---> 码值(97) ---> 二进制(1100001) ---> 存储 

​	**读取**：二进制(1100001) ---> 码值(97) ---> 字符'a' ---> 读取(显示)

​	字符和码值的**对应关系**是通过字符编码决定的。

​	**占位符**： -->  [Here](#C语言占位符)

​	**ASCII码**： -->  [Here](#ASCII码)

- **查看长度** :

  ```c
  printf("length of char: %d\n",sizeof(char));
  ```

- 如果直接%d `a`输出编码 `97`即ASCII码 -->  [Here](#ASCII码)

  ```c
  char ch = 'a';
  printf("%d\n",ch);
  ```

  ```c
  char ch = 'A';
  printf("%d\n",ch+32);
  ```

## 字符串数据

​	**没有字符串类型**，使用**字符数组**来表示**字符串**。

```c
char name[20] = "你好";
```

```c
char name[] = "你好";
```

​	**占位符**： -->  [Here](#C语言占位符)

  ## 布尔型数据

1. C语言标准(C89)没有定义布尔类型，所以c语言判断真假时**以0为假，非0为真**。

2. 但这种做法不直观，所以我们可以借助c语言的宏定义。

3. C语言标准(C99)提供了_Bool型，_Bool仍是整数类型，但与一般整型不同的是，Bool变量只能赋值0或1，非0的值都会被储存位1。

   C99还提供了一个头文件`<stdbool.h>`定义了`bool`代表`_Bool`，true代表1，false代表0。只要导入 stdbool.h，就能方便的操作布尔类型了，比如bool flag = false;

   ```c
   #include <stdbool.h>
   main(){
   	bool flag = false;
       printf("\n%d",c);
   }
   ```

   **可用于**：

   - 条件控制语句;
   - 循环控制语句;

​	**占位符**： -->  [Here](#C语言占位符)

  ## 自定义类型

​	使用`typedef` 自定义类型，相当于取个别名。

```c
#include <stdio.h>
#include <stdint.h>
typedef int64_t hjc_int;
typedef char hjc_char;
void main() {
    hjc_int a = 5;
	hjc_char b = 'a';
    printf("%d",a);

}
```

  ## 数据类型的转换

 C语言允许表达式中混合有不同类型的常量和变量。

 1. **系统自动转换**：容易出现意外结果

​      当参与运算的数据的**类型不同**时，编译系统会自动先将它们转换成**同一类型**，然后再进行运算。

  - 转换的基本规则是“**按数据长度增加的方向进行转换**”，以保证精度不降低。
    <img src="img/类型转换/精度大小.png" >

  <img src="img/类型转换/数据类型自动转换表.png" style="zoom:67%;"   >

​	 比如 int 型数据和 long 型数据进行相加或相减运算时，系统会先将 int 型数据转换成 long 型，然后再进行运算。这样的话运算结果的精度就不会降低。long 是“大水桶”，int 是“小水桶”。int 能存放的，long 肯定能存放；而 long 能存放的，int 不一定能存放。

  - 所有的浮点运算都是以**双精度**进行的。

​     在运算时，程序中所有的 float 型数据全部都会先转换成 double 型。即使只有一个 float 型数据，也会先转换成 double 型，然后再进行运算。因为 CPU 在运算的时候有“字节对齐”的要求，这样运算的速度是最快的。

  - char 型和 short 型数据参与运算时，必须先转换成 int 型。涉及 CPU 的运行原理。
    
  - 有符号整型和无符号整型混合运算时，有符号型要转换成无符号型，运算的结果是无符号的。
    
  - 在赋值运算中，赋值号两边量的数据类型不同时，**赋值号右边量的类型将转换为左边量的类型**，如果右边变量的数据类型长度比左边长时，将丢失一部分数据。**会降低精度**，丢失的部分按**四舍五入向前舍入**。

 2. **强制转换**

​     将精度高的数据类型转换为精度小的数据类型，使用时要加上强制转换符()，但可能造成精度降低或溢出，格外注意。强制类型转换操作**并不改变**操作数本身。

**强制转换表达式**：(数据类型符)表达式; 或 (数据类型符)变量;

   ```c
  double a = 1.5;
  int b = (int)a;
   ```

**注意：**

​	强制类型转换只对最近的数有效，如果希望更多的表达式转换，使用`()`。

```c
int num = (int)(3.5 * 10 + 6 * 5.1);
```

# 指针

​	指针表示一个地址(存放的是地址)

## 基本数据类型

- 基本类型，都有对应的指针类型，形式为 `数据类型 *`


- 如果输出一个变量的地址，使用的格式是`%p`


  - 取出num这个变量对应地址：`&num`


  - 定义一个指针变量，指针：

    ```c
    int *ptr = &num;
    ```

**注意**： **指针的类型和该指针指向的变量是对应关系**

  - 指针变量 本身也有地址：

    ```c
    printf("ptr的地址%p",&ptr);
    ```

  - 获取指针指向的值`*ptr`：

    ```c
    printf("ptr的存放数据%d",*ptr);
    ```

  ## 	数组



  ## 	结构体



  ## 	共同体



  ## 	二级指针



  ## 	多级指针



# 传递参数

​	C语言传递参数(或者赋值)可以是**值传递(pass by value)**，也可以**传递指针(a pointer passed by value)**，传递指针也叫**地址传递**。

## 值传递

​	**默认传递值的类型**：基本数据类型(整型数据、实数类型、字符类型)，结构体，共用体。

​	**值传递**：将变量指向的存储内容，在传递/赋值时，拷贝一份给接受变量。

​	<img src="img\地址传递\值传递.png" >

## 地址传递

​	**默认传递地址的类型**：指针、数组。

​	**地址传递** 也叫 **指针传递**：如果指针，就将指针变量存储的地址，传递给接收变量，如果是**数组，就将数组的首地址传递给接收变量**。

<img src="img\地址传递\地址传递.png" >

# 运算符

​	C语言的基本**表达式**是由**操作数**和**操作符**组成。

​	**操作数**通常是由**变量**或**常量**表示；

​	**操作符**由各种运算符表示。运算符表示数据的**运算**、**赋值**、**比较**等。

​	一个**基本表达式**也可以作为**操作数**来构成**复杂表达式**。构成基本表达式的常用运算符有：

## 算术运算符

​	算术运算符是对**数值类型的变量**进行运算的。

<img src="img/运算符/算术运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

- **取模运算**：

  **取模公式： a % b = a - a / b * b**

  ```c
  int res1 = 10 % 3;	//余数为1
  int res2 = -10 % 3;	//余数为-1
  int res3 = 10 % -3;	//余数为1
  int res4 = -10 % -3; //余数为-1
  ```

  取模运算**只能是整数，不能是实型**。

- **自增、自减运算**：

  - **++(前)/--(前)运算规则**：

  ```c
  int i = 10;
  int j = ++i;	//运算规则等价于 int j = i;i = i + 1;
  ```

  - **(后)++/(后)--运算规则**：

  ```c
  int i = 10;
  int j = i++;	//运算规则等价于 i = i + 1;int j = i;
  ```

  - ++ 或者 -- 可以独立使用，就相当于自增，如果独立使用两者**完全等价**

  ```c
  k++;
  //k++ 等价于 k = k + 1;
  ++k;
  //++k 等价于 k = k + 1;
  ```

**注意**：	

- 对于除号"/" ，它的整数除和小数除是有区别的；整数之间做除法，只会保留整数部分而舍弃小数部分。

  ```c
  //处理流程:10/4 = 2.5 --> 截取整数 --> 2 --> 2.000000
  double a = 10 / 4; //2.000000 
  double b = 10.0 / 4; //如果希望保留小数，参与运算数必须有浮点数
  ```

## 关系运算符

​	关系运算符的结果要么是真(非0表示 默认使用1)要么是假(0)。

​	关系运算符的作用：用于条件判断的表达常用在**if结构的条件中**或**循环结构的条件中**。

<img src="img/运算符/关系运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

​	**关系表达式**：关系运算符组成的表达式。

## 逻辑运算符

​	用于连接**多个条件**(一般来讲是关系表达式)，最终的结果要么是真(非0表示 默认使用1)要么是假(0表示)

​	逻辑运算符的**作用**：用于判断条件中的逻辑关系。

<img src="img/运算符/逻辑运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

​	**逻辑与运算符**：如果两个操作数都非零(真)，则条件为真，否则结果为0(假)。

​	**逻辑或运算符**：如果两个操作数中有任意一个非零，则条件为真。

​	**逻辑非运算符**：用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将其为假。

> 变量A的值为1，变量B为0.
>
> (A && B)为假(0)
>
> (A || B)为真(1)
>
> !(A && B)为真(1)

**说明**：短路现象

​	在进行&&(||)，如果第一个条件为假(真)，则**不再执行**后面的条件，整个结果为假(真)所以，也称为短路逻辑与(或)。

## 赋值运算符

​	赋值运算符就是将某个运算后的值，赋给指定的变量

<img src="img/运算符/赋值运算符.png">

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

**特点**：

1. 运算顺序**从右往左**。
2. 赋值运算符的左边，**只能是变量**，右边可以是**变量、表达式、常量值**。
3. 复合赋值运算符**等价于**：a+=3;等价于a=a+3;。

## 条件运算符

<img src="img/运算符/条件运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

## 自反赋值运算符

<img src="img/运算符/自反赋值运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

## 逗号运算符

<img src="img/运算符/逗号运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

## 指针运算符

<img src="img/运算符/指针运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

## 三元运算符

**基本语法**：

​	**条件表达式 ? 表达式1 ：表达式2;**

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

**说明**：

1. 如果条件表达式为非0(真)，运算后的结果是表达式1。

2. 如果条件表达式为0(假)，运算后的结果是表达式2。

   ```c
   int a = 10;
   int b = 99;
   int res = a > b ? a++ : b--;
   ```

3. 表达式1和表达式2要为可以赋给接收变量的类型(或可以自动转换)，否则会有精度损失。

   ```c
   int n = a > b ? 1.1 : 1.2;//警告 double --> int
   ```

4. 三元运算符可以转换成if-else语句。

## 单目运算符

<img src="img/运算符/单目运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

## 位运算符

​	位运算符作用于位，并逐位执行操作。

<img src="img/运算符/位运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

**说明**：

 1. 按位与操作：两位全为1，结果为1，否则为0。

    ```c
    int a = 2;
    //0000 0000 0000 0000 0000 0000 0000 0010(2)
    int b = -3;
    //1000 0000 0000 0000 0000 0000 0000 0011(-3原码)
    //1111 1111 1111 1111 1111 1111 1111 1100(-3反码)
    //1111 1111 1111 1111 1111 1111 1111 1101(-3补码)
    printf("%d\n",a&b);//0
    //0000 0000 0000 0000 0000 0000 0000 0000(0)
    ```

 2. 按位或操作：两位有一个为1，结果为1，否则为0。

    ```c
    int a = 2;
    //0000 0000 0000 0000 0000 0000 0000 0010(2)
    int b = -3;
    //1000 0000 0000 0000 0000 0000 0000 0011(-3原码)
    //1111 1111 1111 1111 1111 1111 1111 1100(-3反码)
    //1111 1111 1111 1111 1111 1111 1111 1101(-3补码)
    printf("%d\n",a|b);//-1
    //1111 1111 1111 1111 1111 1111 1111 1111(补码)
    //1111 1111 1111 1111 1111 1111 1111 1110(反码)
    //1000 0000 0000 0000 0000 0000 0000 0001(原码 -1)
    ```

 3. 按位异或操作：两位一个为0，一个为1，结果为1，否则其他情况为0。

    ```c
    int a = 2;
    //0000 0000 0000 0000 0000 0000 0000 0010(2)
    int b = -3;
    //1000 0000 0000 0000 0000 0000 0000 0011(-3原码)
    //1111 1111 1111 1111 1111 1111 1111 1100(-3反码)
    //1111 1111 1111 1111 1111 1111 1111 1101(-3补码)
    printf("%d\n",a^b);//-1
    //1111 1111 1111 1111 1111 1111 1111 1111(补码)
    //1111 1111 1111 1111 1111 1111 1111 1110(反码)
    //1000 0000 0000 0000 0000 0000 0000 0001(原码 -1)
    ```

 4. 按位取反：0-->1,1-->0。

    ```c
    int8_t a = 1;//-2
    int8_t a = 0;//-1
    int8_t a = -2;//1
    e =~e;
    //0000 0001(1)
    //1111 1110(反码)
    //1111 1101(补码)
    //1000 0010(原码 -2)
    //-----
    //0000 0000(0)
    //1111 1111(反码)
    //1111 1110(补码)
    //1000 0001(原码 -1)
    //-----
    //1000 0010(-2)
    //1111 1101(反码)
    //1111 1110(补码)
    //0000 0001(1)
    printf("%d",e);
    ```

 5. `<<`在一定的范围内 每向左移1位 相当于 * 2

    `>>`在一定的范围内 每向右移1位 相当于 / 2

    - **最高效方式的计算 2*8    2 << 3  或 8 << 1**

 6. 二进制左移将一个数的各二进制全部左移若干位，**符号位不变，低位补零**。

 7. 二进制右移将一个数的各二进制全部右移若干位，**低位溢出，符号位不变，并用符号位补溢出的高位**。

    ```c
    int a = 1 << 2;//4
    //0000 0000 0000 0000 0000 0000 0000 0001(1)
    //0000 0000 0000 0000 0000 0000 0000 0100(4)
    int a = 1 >> 2;//0
    //0000 0000 0000 0000 0000 0000 0000 0001(1)
    //0000 0000 0000 0000 0000 0000 0000 0000(10 >> 2)
    int a = -10 >> 2;//-3
    //1000 0000 0000 0000 0000 0000 0000 1010(10)
    //1111 1111 1111 1111 1111 1111 1111 0101(反码)
    //1111 1111 1111 1111 1111 1111 1111 0110(补码)
    //1111 1111 1111 1111 1111 1111 1111 1101(-10 >> 2补码)
    //1111 1111 1111 1111 1111 1111 1111 1100(反码)
    //1000 0000 0000 0000 0000 0000 0000 0011(原码)
    int a = -1 >> 2;//-1
    //1000 0000 0000 0000 0000 0000 0000 0001(-1)
    //1111 1111 1111 1111 1111 1111 1111 1110(反码)
    //1111 1111 1111 1111 1111 1111 1111 1111(补码)
    //1111 1111 1111 1111 1111 1111 1111 1111(-1 >> 2)
    //1111 1111 1111 1111 1111 1111 1111 1110(反码)
    //1000 0000 0000 0000 0000 0000 0000 0001(原码)
    ```

**位运算实例之提取颜色通道**

1. 颜色

   ```c
   uint32_t color = 0xFFFFFFFF;//ARGB(Alpha,Red,Green,Bule)
   ```

2. 只取到红色的值

   ```c
   uint32_t color = 0x00FF0000;//ARGB(Alpha,Red,Green,Bule)
   ```

3. 取红色通道值

   ```c
   uint32_t color = 0xFFFEFAFB;//ARGB(Alpha,Red,Green,Bule)
   //1111 1111 1111 1110 1111 1010 1111 1011
   uint32_t tmp = color&0x00FF0000;
   //0000 0000 1111 1111 0000 0000 0000 0000
   uint8_t red = tmp >> 16;
   printf("%d\n",red);
   ```

## 逗号运算符

<img src="img/运算符/逗号运算符.png" >

​	运算符的优先级和结合性 --> [Here](#运算符的优先级和结合性)

int a,b;不是逗号表达式

不建议经常使用

# 进制

**采用不同的进制的原因**是不同的领域用到的技术形式不相同　

- 在计算机底层都以**二进制**形式存在。

## 进位计数制

​	**按照进位的方法进行计数，称为进位计数制。**

​	**常见的进位计数制**：二进制、八进制、十进制、十二进制、十六进制等等。

  **R进制数的特点：**

- 具有R个不同的数符。0，1，2．．．，R－１

- 逢R进一。

  进位计数制的一般表达式(按权展开式)：

  R进制的表示方法，任一R进制数S可表示为

  > S=a<sub>n-1</sub> a<sub>n-2</sub> ... a<sub>1</sub> a<sub>0</sub> . a<sub>-1</sub>...+a<sub>-m</sub>           位置表示法
  >
  >   =a<sub>n-1</sub>R<sup>n-1</sup> + ... + a<sub>1</sub>R<sup>1</sup> + a<sub>0</sub>R<sup>0</sup> + a<sub>-1</sub>R<sup>-1</sup> ... +a<sub>-m</sub>R<sup>-m</sup> (按权展开式)
  >
  > 其中:a<sub>i</sub> : R 进制中的数字符号
  >
  > ​		 R：基数
  >
  > ​         R<sup>i</sup> : 位权，简称权

##  十进制N<sub>D</sub>

**特点：**

1. 有十个数码：0~9

2. 逢十进一

加权展开式以10为基数，各位系数为0~9

> ​	N<sub>D</sub> = d<sub>n-1</sub> * 10<sup>n-1</sup> + d<sub>n-2</sub> * 10<sup>n-2</sup>+...+d<sub>0</sub> * 10<sup>0</sup>+d<sub>-1</sub> * 10<sup>-1</sup>+...

​	例:(1234.5)<sub>10</sub> = 1 * 10<sup>3</sup> + 2 * 10<sup>2</sup> +3 * 10<sup>1</sup> +  4 * 10<sup>0</sup> +5 * 10<sup>-1</sup> 

## 	二进制N<sub>B</sub>

**特点**：

1. 有两个数码：0、1

2. 逢二进一

加权展开式以2为基数，各位系数为0、1

> N<sub>B</sub> = b<sub>n-1</sub> * 2<sup>n-1</sup> + b<sub>n-2</sub> * 2<sup>n-2</sup>+...+b<sub>0</sub> * 2<sup>0</sup>+b<sub>-1</sub> * 2<sup>-1</sup>+...

例: `1101.101B` = 1 * 2<sup>3</sup> + 1 * 2<sup>2</sup> +0 * 2<sup>1</sup> +  1 * 2<sup>0</sup> +1 * 2<sup>-1</sup> +0 * 10<sup>-2</sup> +1 * 2<sup>-3</sup> 

**注意:**不够八位最好前面加上0 凑成八位

## 八进制N<sub>O/Q</sub>

**特点：**

1. 有八个数码：0~7

2. 逢八进一

加权展开式以8为基数，各位系数为0、1

> N<sub>O</sub> = b<sub>n-1</sub> * 8<sup>n-1</sup> + b<sub>n-2</sub> * 8<sup>n-2</sup>+...+b<sub>0</sub> * 8<sup>0</sup>+b<sub>-1</sub> * 8<sup>-1</sup>+...

例: `7451` =  7 * 8<sup>3</sup> + 4 * 8<sup>2</sup> +5 * 8<sup>1</sup> +  1 * 8<sup>0</sup> 

## 十六进制N<sub>H</sub>

​	因为二进制太长 所以采用十六进制 

​	一位十六进制可以表示四位二进制

**特点：**

1. 有十六个数码：0~9、A~F

2. 逢十六进一

加权展开式以16为基数，各位系数为0~9，A~F

> N<sub>H</sub> = h<sub>n-1</sub> * 16<sup>n-1</sup> + h<sub>n-2</sub> * 16<sup>n-2</sup>+...+h<sub>0</sub> * 16<sup>0</sup>+h<sub>-1</sub> * 16<sup>-1</sup>+...

例:`DFC.8H` = 13 * 16<sup>2</sup> +15 * 16<sup>1</sup> +  12 * 16<sup>0</sup> +8 * 16<sup>-1</sup> 

**注意**

不同进位制数以后缀区别,十进制数可不 带后缀。或加括弧，再在括弧之后注明。

- `101`、`101D`、`101B`、`101H`、`101H`
- (20)<sub>10</sub>、(1101)<sub>2</sub>、(345)<sub>16</sub>


## 不同进制计数制的转换

### 			二进制、十六进制转换成十进制

**方法：**

​			先将二、十六进制数按权展开，然后按照十进制运算法则求和

**举例：** 

​			`1011.1010B`=1 * 2<sup>3</sup>+1 * 2<sup>1</sup>+1 * 2<sup>0</sup>+1 * 2<sup>-1</sup>+1*2<sup>-3</sup>

​								   =(11.625)<sub>10</sub>

​			`DFC.8H`=13 * 16<sup>2</sup> + 15 * 16<sup>1</sup> + 12 * 16<sup>0</sup> + 8 * 16<sup>-1</sup> 

​						  =(3580.5)<sub>10</sub>

### 			十进制转换成二进制、十六进制

**方法：**

​	**整数部分,除基取余**

​		不断**除以**所要转换的进制基数，直至**商为0**。每除一次取一个余数，从低位排向高位。

​	**小数部分,乘基取整**
​		用转换进制的基数乘以小数部分，直至小数为0或达到转换精度要求的位数。每**乘一次取一次整数**，从最高位排到最低位。

**举例：**

​	**二进制最好前面加上0 凑成八位**

​	39转换成二进制数        
​	(39)<sub>10</sub>=`00100111B`

​	208转换成十六进制数   
​	`208D` = `D0H`

​	`0.625D`转换成十六进制数
​	0.625 × 16 = 10.0	 `0.625D` = `0.AH`

​	`208.625D` 转换成十六进制数 
​	`208.625D`= `D0.AH`

​	0.25十进制 转换成 二进制数
​	`0.25D`=`0.01B`

​	(15.8125)<sub>10</sub>转换成二进制数 	
​	(15.8125)<sub>10</sub>=`00001111.1101`

<img src="img/进制/15.8125.png" >

​        

### 二进制转换成十六进制

​	由2<sup>4</sup>=16可知 四位二进制数对应一位十六进制数。
例:   `3AF.2H` 
​      		= <u>0011</u> <u>1010</u> <u>1111</u>.<u>0010</u> =`1110101111.001B` 	
​				      3      A       F        2

​           `1111101.11B` 
​			   = <u>0111</u> <u>1101</u>.<u>1100</u>  = `7D.CH`         
​					  7       D       C
​    二进制转换为16进制时，整数部分从**最低位**进行划分，**每4位二进制数为一组**，不足4位的，最高位补零；**小数部分**从**最高位**进行划分，每4位二进制数为一组，不足4位的最低为补零

## 技巧：

​	按照`8421`方法，即对应二进制四位

### 			十六进制转为二进制


​				`8421`排列组合成十六进制数

​				`37FH`

​					=  	  3 	    7 	    F
​					   	`8421` `8421` `8421`

​						    **0011  0111  1111**

### 			 二进制转换为十六进制


​				每四位为一个 `8421`

​				`0110111100B`

​					=     <u>0001</u>  <u>1011</u>  <u>1100</u>
​					   	`8421` `8421` `8421`

​							    **1        B         C**		

### 			八进制二进制互相转换


​				同理，只不过将 `8421` 变为 `421`

​				`11010110`

​					=  	  11   010   110
​					    	`421`  `421`  `421`

​    						    **3       2       6**
​				
​				`765`

​					=  	  7        6       5
​					    	`421`  `421`  `421`

​    			     	    **111    110     101**

### 		十进制转换二进制


​				可将十进制先转换成十六进制再转成二进制

​				`39D`

​					=  	 <u>39</u> / 16		余7 

​								2	           余2
​					
​					=    `2    7  H`
​					= `8421` `8421`

​					= **0010   0111**  B
​				`0.25D`

​					=  	 <u>0.25</u> * 16		=4
​					=    `0.4H`
​					= `8421` 

​					= **0.01**  B

## 	原码、反码、补码

对于有符号的而言：

 1. 二进制的最高位是符号位：0表示正数，1表示负数。

 2. 正数的原码、反码、补码都一样(三码合一)。

 3. 负数的反码=他的原码符号位不变，其他位取反(0-->1 1-->0)。

 4. 负数的补码=它的反码+1

 5. 0的反码、补码都是0

 6. 计算机运算的时候，都是以**补码的方式**来运算。	

    ```c
    //2的原码、反码、补码
    //0000 0000 0000 0000 0000 0000 0000 0010
    //-3的原码
    //1000 0000 0000 0000 0000 0000 0000 0011
    //-3的反码
    //1111 1111 1111 1111 1111 1111 1111 1100
    //-3的补码
    //1111 1111 1111 1111 1111 1111 1111 1101
    ```

# 顺序控制结构

​	程序从上到下逐行地执行，中间没有任何判断和跳转

**说明**：

​	C中定义变量时采用合法的**前向引用的原则**

```c
void main(){
    int num1 = 12;
    int num2 = num1 + 2;
    //错误形式
    //int num2 = num1 + 2;
    //int num1 = 12;
}
```

## 赋值语句



## 数据输出



## 数据输入



## 复合语句和空语句



# 选择控制结构

## if语句

​	如果if中的代码块，只有一条语句，则可以省略{}(**不推荐**)

### 单分支

**基本语法**

```c
if(条件表达式){
	执行代码块;
}
```

**说明**

​	当条件表达式为真(非0)时，就会执行{ }的代码，返回假(0)时，不会执行{ }的代码。

**流程图**

<img src="img/控制结构/单分支.png" style="zoom:67%;" >

### 双分支

**基本语法1**

```c
if(条件表达式){
    执行代码块1;
}else{
    执行代码块2;
}
```

**说明**

​	当条件表达式成立(为真)，执行代码块1，否则执行代码块2。

**流程图**

<img src="img/控制结构/双分支.png" style="zoom:67%;" >

**基本语法2**

```c
if(条件表达式1){
    执行代码块1;
}else if(条件表达式2) {
    执行代码块2;
}else if(条件表达式3) {
    执行代码块3;
}...
else{
    执行代码块n;
}
```

**说明**

​	当条件表达式成立(为真)，执行代码块1，否则执行代码块2。

**流程图**

<img src="img/控制结构/双分支2.png" style="zoom:67%;" >

![image-20211019173405809](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211019173405809.png)

### 嵌套分支

![image-20211023010754334](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023010754334.png)





## switch语句

如果没有break 程序会一直往下走 直到break 或程序结束

![image-20211023011441646](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023011441646.png)

![image-20211023144444814](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023144444814.png)

![image-20211023144743458](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023144743458.png)

![image-20211023150239078](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023150239078.png)

![image-20211023150348427](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023150348427.png)

![image-20211023152436628](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023152436628.png)



## 语句标号和goto语句

label是标签 goto label 是跳到label

![img](D:\Data\zhan885844@163.com\a617c92136a341ed924cbe3a7ce4375a\截图.png)

输出1-100

![img](D:\Data\zhan885844@163.com\6e1ebebac4124a3f8f956ef9eb3c01c5\截图.png)



# 循环控制结构

## while语句

while 先判断后执行

![img](D:\Data\zhan885844@163.com\a13289fa65dc483aa851d9934018b28a\截图.png)

只输出奇数

![img](D:\Data\zhan885844@163.com\4f96cecc4fc34ad38193cd59307d16c7\截图.png)

也可以

![img](D:\Data\zhan885844@163.com\b565e536d7364cc494174bb21c140b67\截图.png)

## do-while语句

do-while 先执行后判断

![img](D:\Data\zhan885844@163.com\185d8eb5368d43ee9a1d4162b149420e\截图.png)

数学运算符

![img](D:\Data\zhan885844@163.com\e92da663ced74ed295c53b6e648ba80a\截图.png)

三角函数

![img](D:\Data\zhan885844@163.com\c2aad8de0f7248099535c6fc5428ab7f\截图.png)

![img](D:\Data\zhan885844@163.com\e86fa94080824a82956b44591b9d6ac9\截图.png)

## for循环

![image-20211023152633468](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211023152633468.png)



![img](D:\Data\zhan885844@163.com\47469f3e474240fe9c0e700fc15f69ba\截图.png)

![img](D:\Data\zhan885844@163.com\8a40e8f5ba8b460faedc3cf58ef14bb1\截图.png)

## 嵌套循环结构

嵌套循环

![img](D:\Data\zhan885844@163.com\c242d67c83924bbfa8821f853545298f\截图.png)

九九乘法表

![img](D:\Data\zhan885844@163.com\92d2bb30f44842e0b86df1dcb23d73cb\截图.png)

![img](D:\Data\zhan885844@163.com\3bed8531e6bc427bbdf23e474737e0e7\截图.png)

## break和continue语句

continue

只是跳过本次循环继续下一循环

![img](D:\Data\zhan885844@163.com\293a517c04e74800935720056938bb89\截图.png)

# 枚举



# 函数



# 宏定义



# 数组

# 结构体

# 共同体

# 试题及练习

# 项目





# 附录


  - ## C语言关键字

     <img src="img/附录/C语言关键字.png"  >
     
  - ## C语言占位符

     <img src="img/附录/数据类型和占位符对应关系.png" style="zoom:67%;" >

     <img src="img/附录/格式占位符.png" style="zoom:67%;" >

     - **对于float类型的变量，printf()中的说明符可以用%f或%lf，而scanf()中的说明符则只能**

     **用%f**

     - **对于double类型的变量，printf()中的说明符可以用%f或%lf，而scanf()中的说明符则只**

     **能用%lf**

     - **对于long double类型的变量，printf()中的说明符可以用%f或%lf，而scanf()中的说明符**

     **则只能用%lf**

     

     小数形式的实数，默认情况保留小数点6位，**保留小数点后n位数→%.nf (n<=6)**

     **据大小自动选f格式或e格式，且去掉无意义的零**:`%g`/`%lg`

  - ## C语言标准库

     ​	C标准库是一组C内置函数、常量、头文件。

     - --->[assert.h](/C语言标准库/assert.h)

     - --->[ctype.h](/C语言标准库/ctype.h)

     - --->[errno.h](/C语言标准库/errno.h)

     - --->[float.h](/C语言标准库/float.h)

     - --->[limits.h](/C语言标准库/limits.h)

     - --->[locale.h](/C语言标准库/locale.h)

     - --->[math.h](/C语言标准库/math.h)

     - --->[setjmp.h](/C语言标准库/setjmp.h)

     - --->[signal.h](/C语言标准库/signal.h)

     - --->[stdarg.h](/C语言标准库/stdarg.h)

     - --->[stddef.h](/C语言标准库/stddef.h)

     - --->[stdio.h](/C语言标准库/stdio.h)

     - --->[stdlib.h](/C语言标准库/stdlib.h)

     - --->[string.h](/C语言标准库/string.h)

     - --->[time.h](/C语言标准库/time.h)

     getchar()函数：从控制台读取字符并立即回显，用于从标准输入控制台读取字符。

  - ## 进制之间的转换

     ![img](D:\Data\zhan885844@163.com\3a295a95621a4ba5b3132a1ea2b5c427\clipboard.png)


  - ## ASCII码

     **介绍：**

     ​	在计算机内部,所有数据都使用**二进制**表示。每一个二进制位(bit)有0和1两种状态,因此8个二进制位就可以组合出**256种**状态,这被称为一个字节(byte).一个字节一共可以用来表示256种不同的状态,每一个状态对应一个符号,就是256个符号,从0000000到11111111.

     ​	ASCII码:上个世纪60年代,美国制定了一套字符编码,对英语字符与二进制位之间的关系,做了统一规定。这被称为ASCII码。 ASCII码一共规定了128个字符的编码,比如空格"SPACE"是32 (二进制00100000) ,大写的字母A是65 (二进制01000001) 。这128个符号(包括32个不能打印出来的控制符号) ,只占用了一个字节的后面7位,最前面的1位统一规定为0

     **缺点:**

     ​	不能表示所有字符。

     ​	相同的编码表示的字符不一样,比如, 130在法语编码中代表了ё,在希伯来语编码中却代表了字母Gimel (ξ)

     ​	<img src="" >

  - ## 常用转义字符

    <img src="img/附录/转义字符.png" style="zoom:67%;" >  

  


  - ## 运算符的优先级和结合性

    <img src="img/附录/运算符优先级.png" >

    <img src="img/附录/运算符优先级2.png" >

    ![image-20211011230025698](C:\Users\LetengZzz\AppData\Roaming\Typora\typora-user-images\image-20211011230025698.png)

    ​	说明 ：同一优先级的运算次序由结合方向决定。例如，*号和/号有相同的优先级，其结合方向为自左至右，因此，`3*5/4`的运算次序是先乘后除。单目运算符--和++具有同一优先级，结合方向为自右至左，因此，表达式:--i++ 相当于 --(i++)

    ​	小结 ：

     	1. 结合方向只有三个是从右到左，其余都是从左到右。
     	2. 所有双目运算符中只有赋值运算符的结合方向是从右向左。
     	3. 另外两个从右到左的结合运算符是：单目运算、三目运算。
     	4. 逗号的运算符优先级最低。
     	5. 大致优先级顺序：算术运算符 > 关系运算符 ＞ 逻辑运算符(逻辑非! 除外) > 赋值运算符 > 逗号运算符。

  - ## 双目运算符中两边运算量 类型转换规律

    运算所需变量为**两个**的运算符叫做双目运算符，或者要求运算对象的**个数是2**的运算符称为双目运算符。

    <img src="img\附录\双目运算符中.png" >


  - ## int补充知识

     在`C99`标准中定义了这些数据类型，具体定义在：`/usr/include/stdint.h   ISO C99: 7.18 Integer types`

     ```c
     #ifndef __int8_t_defined  
     # define __int8_t_defined  
     typedef signed char             int8_t;   
     typedef short int               int16_t;  
     typedef int                     int32_t;  
     # if __WORDSIZE == 64  
     typedef long int                int64_t;  
     # else  
     __extension__  
     typedef long long int           int64_t;  
     # endif  
     #endif  
       
       
     typedef unsigned char           uint8_t;  
     typedef unsigned short int      uint16_t;  
     #ifndef __uint32_t_defined  
     typedef unsigned int            uint32_t;  
     # define __uint32_t_defined  
     #endif  
     #if __WORDSIZE == 64  
     typedef unsigned long int       uint64_t;  
     #else  
     __extension__  
     typedef unsigned long long int  uint64_t;  
     #endif  
     ```

     首先要添加`stdint.h`

     ```c
     #include <stdint.h>
     ```

     **有符号类型**

     - ​	int8_t

     意思是8位整数(`8bit integer`)，八位等于一个字节 一个字节等于 -128-127所以`int8` 不超过-128-127

     ```
     int8_t a = 1;
     ```

     - ​	int16_t

     意思是16位整数(`16bit integer`)，相当于short 占2个字节  -32768 ~ 32767

     ```
     int16_t a = 1;
     ```

     - ​	int32_t

     意思是32位整数(`32bit integer`), 相当于 int   占4个字节  -2147483648 ~ 2147483647

     `int32_`就是常见int

     ```c
     int32_t a = 1;
     ```

     - ​	int64_t

     意思是64位整数(`64bit interger`), 相当于 long long  占8个字节  -9223372036854775808 ~ 9223372036854775807

     ```c
     int64_t a = 1;
     ```

     **无符号类型**

     uint8是无符号 就是 0-255，uint8_t 实际是一个 char

     ```c
     uint8_t a = 1;
     ```

  - ## 常见问题及解决方法

     ```c
     LINK : fatal error LNK1104
     ```

     没有连接成功，无法打开

     **解决办法**：修改源文件后，需要关闭控制台，才能正确运行

     ```
     error C2143 语法错误 缺少;
     ```

     缺少分号

     **解决办法**：编译失败，注意错误出现的行数，再到源代码中指定位置改错

  - ### hello world

